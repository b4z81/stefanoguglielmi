{"version":3,"sources":["grid/animOnScroll.js"],"names":["window","scrollY","pageYOffset","docElem","scrollTop","getViewportH","client","inner","getOffset","el","offsetTop","offsetLeft","isNaN","offsetParent","top","left","inViewport","h","elH","offsetHeight","scrolled","viewed","elTop","extend","a","b","key","hasOwnProperty","AnimOnScroll","options","this","defaults","_init","document","documentElement","support","animations","Modernizr","cssanimations","animEndEventNames","WebkitAnimation","OAnimation","msAnimation","animation","animEndEventName","prefixed","onEndAnimation","callback","onEndCallbackFn","ev","target","removeEventListener","call","addEventListener","prototype","minDuration","maxDuration","viewportFactor","self","items","slice","children","itemsCount","length","itemsRenderedCount","didScroll","forEach","i","_checkTotalRendered","classie","add","_onScrollFn","_resizeHandler","setTimeout","_scrollPage","has","randDuration","Math","random","style","WebkitAnimationDuration","MozAnimationDuration","animationDuration","remove","delayed","resizeTimeout","clearTimeout"],"mappings":"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","file":"grid/animOnScroll.js","sourcesContent":["/**\n * \"loading\" effects for grids from/based on: http://tympanus.net/codrops/2013/07/02/loading-effects-for-grid-items-with-css-animations/ (Check it out for more examples and effects)\n * \n * animOnScroll.js\n * http://www.codrops.com\n *\n * Licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n * \n * Copyright 2016, Codrops\n * http://www.codrops.com\n */\n;(function(window) {\n\n\t'use strict';\n\n\tvar docElem = window.document.documentElement;\n\n\t// some helper functions\n\tfunction scrollY() { return window.pageYOffset || docElem.scrollTop; }\n\n\tfunction getViewportH() {\n\t\tvar client = docElem['clientHeight'],\n\t\t\tinner = window['innerHeight'];\n\t\t\n\t\tif( client < inner )\n\t\t\treturn inner;\n\t\telse\n\t\t\treturn client;\n\t}\n\n\t// http://stackoverflow.com/a/5598797/989439\n\tfunction getOffset( el ) {\n\t\tvar offsetTop = 0, offsetLeft = 0;\n\t\tdo {\n\t\t\tif ( !isNaN( el.offsetTop ) ) {\n\t\t\t\toffsetTop += el.offsetTop;\n\t\t\t}\n\t\t\tif ( !isNaN( el.offsetLeft ) ) {\n\t\t\t\toffsetLeft += el.offsetLeft;\n\t\t\t}\n\t\t} while( el = el.offsetParent )\n\n\t\treturn {\n\t\t\ttop : offsetTop,\n\t\t\tleft : offsetLeft\n\t\t}\n\t}\n\n\tfunction inViewport( el, h ) {\n\t\tvar elH = el.offsetHeight,\n\t\t\tscrolled = scrollY(),\n\t\t\tviewed = scrolled + getViewportH(),\n\t\t\telTop = getOffset(el).top,\n\t\t\telBottom = elTop + elH,\n\t\t\t// if 0, the element is considered in the viewport as soon as it enters.\n\t\t\t// if 1, the element is considered in the viewport only when it's fully inside\n\t\t\t// value in percentage (1 >= h >= 0)\n\t\t\th = h || 0;\n\n\t\treturn (elTop + elH * h) <= viewed;// && (elBottom - elH * h) >= scrolled;\n\t}\n\n\tfunction extend( a, b ) {\n\t\tfor( var key in b ) { \n\t\t\tif( b.hasOwnProperty( key ) ) {\n\t\t\t\ta[key] = b[key];\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tvar support = { animations : Modernizr.cssanimations },\n\t\tanimEndEventNames = { 'WebkitAnimation' : 'webkitAnimationEnd', 'OAnimation' : 'oAnimationEnd', 'msAnimation' : 'MSAnimationEnd', 'animation' : 'animationend' },\n\t\tanimEndEventName = animEndEventNames[ Modernizr.prefixed( 'animation' ) ],\n\t\tonEndAnimation = function( el, callback ) {\n\t\t\tvar onEndCallbackFn = function( ev ) {\n\t\t\t\tif( support.animations ) {\n\t\t\t\t\tif( ev.target != this ) return;\n\t\t\t\t\tthis.removeEventListener( animEndEventName, onEndCallbackFn );\n\t\t\t\t}\n\t\t\t\tif( callback && typeof callback === 'function' ) { callback.call(); }\n\t\t\t};\n\t\t\tif( support.animations ) {\n\t\t\t\tel.addEventListener( animEndEventName, onEndCallbackFn );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tonEndCallbackFn();\n\t\t\t}\n\t\t};\n\n\tfunction AnimOnScroll(el, options) {\t\n\t\tthis.el = el;\n\t\tthis.options = extend( this.defaults, options );\n\t\tthis._init();\n\t}\n\n\tAnimOnScroll.prototype = {\n\t\tdefaults : {\n\t\t\t// Minimum and a maximum duration of the animation (a random value is chosen)\n\t\t\tminDuration : 0,\n\t\t\tmaxDuration : 0,\n\t\t\t// The viewportFactor defines how much of the item has to be visible in order to trigger the animation\n\t\t\t// if we'd use a value of 0, this would mean that it would trigger the animation as soon as the item is in the viewport. \n\t\t\t// If we were to use the value of 1, the animation would only be triggered when we see all of the item inside the viewport.\n\t\t\tviewportFactor : 0.2\n\t\t},\n\t\t_init : function() {\n\t\t\tvar self = this;\n\n\t\t\tthis.items = [].slice.call(this.el.children);\n\t\t\tthis.itemsCount = this.items.length;\n\t\t\tthis.itemsRenderedCount = 0;\n\t\t\tthis.didScroll = false;\n\t\t\t\n\t\t\t// the items already shown...\n\t\t\tthis.items.forEach( function( el, i ) {\n\t\t\t\tif( inViewport( el ) ) {\n\t\t\t\t\tself._checkTotalRendered();\n\t\t\t\t\tclassie.add( el, 'shown' );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// animate the items inside the viewport on scroll\n\t\t\twindow.addEventListener( 'scroll', function() {\n\t\t\t\tself._onScrollFn();\n\t\t\t}, false );\n\t\t\twindow.addEventListener( 'resize', function() {\n\t\t\t\tself._resizeHandler();\n\t\t\t}, false );\n\t\t},\n\t\t_onScrollFn : function() {\n\t\t\tvar self = this;\n\t\t\tif( !this.didScroll ) {\n\t\t\t\tthis.didScroll = true;\n\t\t\t\tsetTimeout( function() { self._scrollPage(); }, 60 );\n\t\t\t}\n\t\t},\n\t\t_scrollPage : function() {\n\t\t\tvar self = this;\n\t\t\tthis.items.forEach( function( el, i ) {\n\t\t\t\tif( !classie.has( el, 'shown' ) && !classie.has( el, 'animate' ) && inViewport( el, self.options.viewportFactor ) ) {\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tself._checkTotalRendered();\n\n\t\t\t\t\t\tif( self.options.minDuration && self.options.maxDuration ) {\n\t\t\t\t\t\t\tvar randDuration = ( Math.random() * ( self.options.maxDuration - self.options.minDuration ) + self.options.minDuration ) + 's';\n\t\t\t\t\t\t\tel.style.WebkitAnimationDuration = randDuration;\n\t\t\t\t\t\t\tel.style.MozAnimationDuration = randDuration;\n\t\t\t\t\t\t\tel.style.animationDuration = randDuration;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tclassie.add( el, 'animate' );\n\t\t\t\t\t\tonEndAnimation(el, function() {\n\t\t\t\t\t\t\tclassie.add( el, 'shown' );\n\t\t\t\t\t\t\tclassie.remove( el, 'animate' );\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 25 );\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.didScroll = false;\n\t\t},\n\t\t_resizeHandler : function() {\n\t\t\tvar self = this;\n\t\t\tfunction delayed() {\n\t\t\t\tself._scrollPage();\n\t\t\t\tself.resizeTimeout = null;\n\t\t\t}\n\t\t\tif ( this.resizeTimeout ) {\n\t\t\t\tclearTimeout( this.resizeTimeout );\n\t\t\t}\n\t\t\tthis.resizeTimeout = setTimeout( delayed, 100 );\n\t\t},\n\t\t_checkTotalRendered : function() {\n\t\t\t++this.itemsRenderedCount;\n\t\t\tif( this.itemsRenderedCount === this.itemsCount ) {\n\t\t\t\twindow.removeEventListener( 'scroll', this._onScrollFn );\n\t\t\t}\n\t\t}\n\t}\n\n\twindow.AnimOnScroll = AnimOnScroll;\n\n})(window);"],"sourceRoot":"/source/"}